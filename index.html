<!doctype html>
<html>
    <head>
      <style>
          html, body {
              padding:0;
              margin:0;
              background:#000000;
          }

          .models {
              position:absolute;
              top:10px;
              left:12px;
              z-index:2;
              font-family: "Arial", "Helvetica Neue", "Helvetica", sans-serif;
              font-size:13px;
          }

          .notes {
              position:absolute;
              left:12px;
              bottom:10px;
              z-index:2;
              font-family: "Arial", "Helvetica Neue", "Helvetica", sans-serif;
              font-size:13px;
              text-align:left;
              color:#FFFFFF;
              max-width:300px;
          }

          .notes a, .notes a:visited {
              color:#FFFFFF;
          }

          .models strong {
              color:#FFFFFF;
              text-transform: uppercase;
              display:inline-block;
              min-width:110px;
          }

          .models a, .models a:visited {
              color:#FFFFFF;
              margin-right:8px;
              text-decoration: none;
          }

          .models a:hover, .models a:focus {
              text-decoration: underline;
          }
      </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/103/three.js"></script>
        <script src="implementations/three-prwm-loader/PRWMLoader.js"></script>
    </head>
    <body>
        <div class="models">

        </div>
        <div class="notes">
            <strong id="endianness">
            </strong>
        </div>
        <script>

            var container;

            var camera, scene, renderer;

            var mouseX = 0, mouseY = 0;

            var windowHalfX = window.innerWidth / 2;
            var windowHalfY = window.innerHeight / 2;


            init();

            animate();


            function init() {
                container = document.createElement( 'div' );
                document.body.appendChild( container );

                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
                camera.position.z = 950;

                // scene

                scene = new THREE.Scene();

                var ambient = new THREE.AmbientLight( 0x252525 );
                scene.add( ambient );

                var directionalLight = new THREE.DirectionalLight( 0xaf0404 ,5);
                directionalLight.position.set( 1, 3, -3 );
                scene.add( directionalLight );

                // model

                var loader = new THREE.PRWMLoader();
                var material = new THREE.MeshPhongMaterial({
                    side: THREE.FrontSide
                });

                var material = new THREE.MeshBasicMaterial({
                    map: new THREE.TextureLoader().load( "assets/images/tst-uvmap.jpg" )
                });

                var busy = false;
                var mesh = null;

                var onProgress = function ( xhr ) {
                    if ( xhr.lengthComputable ) {
                        var percentComplete = xhr.loaded / xhr.total * 100;
                        console.log( Math.round(percentComplete, 2) + '% downloaded' );

                        if (xhr.loaded === xhr.total) {
                            console.log('File size: ' + (xhr.total / 1024).toFixed(2) + 'kB');
                            console.timeEnd('Download');
                        }
                    }
                };

                var onError = function ( xhr ) {
                    busy = false;
                };

                function loadGeometry (url) {
                    if (busy) return;

                    busy = true;

                    if (mesh !== null) {
                        scene.remove(mesh);
                        mesh.geometry.dispose();
                    }

                    console.log('-- Loading', url);
                    console.time('Download');
                    loader.load( url, function ( geometry ) {
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.scale.set(50,50,50);
                        scene.add( mesh );

                        console.log(geometry.index ? 'indexed geometry' : 'non-indexed geometry');
                        console.log('# of vertices: ' + geometry.attributes.position.count);
                        console.log('# of polygons: ' + (geometry.index ? geometry.index.count / 3 : geometry.attributes.position.count / 3));
                        busy = false;
                    }, onProgress, onError );
                }


                //

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setPixelRatio( 1 );
                renderer.setSize( window.innerWidth, window.innerHeight );
                container.appendChild( renderer.domElement );

                document.addEventListener( 'mousemove', onDocumentMouseMove, false );

                //

                document.querySelectorAll('a.model').forEach(function (anchor) {
                    anchor.addEventListener('click', function (e) {
                        e.preventDefault();

                        loadGeometry(anchor.href);
                    });
                });

                //

                loadGeometry('models/prwm/IWP.le.prwm');

                window.addEventListener( 'resize', onWindowResize, false );

            }


            function onWindowResize() {

                windowHalfX = window.innerWidth / 2;
                windowHalfY = window.innerHeight / 2;

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function onDocumentMouseMove( event ) {

                mouseX = ( event.clientX - windowHalfX ) / 1;
                mouseY = ( event.clientY - windowHalfY ) / 1;

            }

            //

            function animate() {

                requestAnimationFrame( animate );
                render();

            }

            function render() {

                camera.position.x += ( -mouseX - camera.position.x ) * .01;
                camera.position.y += (  mouseY - camera.position.y ) * .01;

                camera.lookAt( scene.position );

                renderer.render( scene, camera );

            }

        </script>
    </body>
</html>
